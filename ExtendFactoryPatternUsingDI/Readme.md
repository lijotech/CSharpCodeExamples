## Extend the Factory Design Pattern Using Dependency Injection (DI)

The combination of the Factory Design Pattern and Dependency Injection (DI) can lead to more modular, maintainable, and testable code. Let’s explore various use cases where this combination shines.

## 1. Service Initialization with Dependency Injection
Consider a service that generates Vehicle Identification Numbers (VINs). Initially, we can register this service in the DI container:

```
public class VinLabelGenService
{
    public string Prefix { get; }
    public VinLabelGenService(string prefix)
    {
        Prefix = prefix;
    }
    public string Generate() => $"{Prefix}{Guid.NewGuid()}";
}

private static void ConfigureServices(IServiceCollection services)
{
    // Register your services here
    services.AddSingleton<VinLabelGenService>(serviceProvider =>
    {              
        return new VinLabelGenService(Contants.VINPREFIX);
    });
}
```

## 2. Using Factory Pattern for Dynamic Service Creation
When the prefix for the VIN is generated by another service, we can use the Factory Pattern to encapsulate this logic:

> Scenario: Let us assume if the prefix is generated by third party service. In this case we can use a factory pattern.

```
 public class PrefixGenService : IPrefixGenService
 {
     public string GetPrefix()
     {
         // Get the current month name
         string monthName = DateTime.Now.ToString("MMMM");

         // Get the first and last letter of the month name
         string prefix = monthName[0].ToString() + monthName[monthName.Length - 1].ToString();

         return prefix.ToUpper();
     }
 }
```

Now we can use factory to call the service to get the prefix and then return the `VinLabelGenService` instance. This approach offers better encapsulation and a decoupled architecture. By doing this, we get rid of the direct dependency on a third-party service. Instead, we now can inject/resolve our own factory dependency and get access to that service 

```
   public class LabelGenServiceFactory
   {
       private readonly VinLabelGenService _vinLabelGenService;
       private readonly IPrefixGenService _prefixGenService;

       public LabelGenServiceFactory(IPrefixGenService prefixGenService)
       {
           _prefixGenService = prefixGenService;
           _vinLabelGenService = new(_prefixGenService.GetPrefix());
       }

       public VinLabelGenService GetVinLabelGenService() => _vinLabelGenService;
   }
```

## 3. Conditional Object Instantiation
For generating different types of vehicles, we can use the Factory Pattern to create instances based on the vehicle type:

> Scenario: Imagine if we want to generate different types of vehicle using a generated label.

first we create a abstract class

```
 public abstract class Vehicle(string vinLabel)
 {
     public abstract void Design();
     public abstract void Manufacture();
 }
```

then we create the different vehicle models
```
 public class Car(string vinLabel) : Vehicle(vinLabel)
 {
     private readonly string _vinLabel = vinLabel;

     public override void Design() => Console.WriteLine($"Designing a car with vin {_vinLabel}...");
     public override void Manufacture() => Console.WriteLine("Manufacturing a car...");
 }
 public class Bike(string vinLabel) : Vehicle(vinLabel)
 {
     private readonly string _vinLabel = vinLabel;

     public override void Design() => Console.WriteLine($"Designing a bike with vin {_vinLabel}...");
     public override void Manufacture() => Console.WriteLine("Manufacturing a bike...");
 }
 public class Truck(string vinLabel) : Vehicle(vinLabel)
 {
     private readonly string _vinLabel = vinLabel;

     public override void Design() => Console.WriteLine($"Designing a truck with vin {_vinLabel}...");
     public override void Manufacture() => Console.WriteLine("Manufacturing a truck...");
 }
```

finally we create vehicle factory
```
 public  class VehicleFactory: IVehicleFactory
 {
     private readonly LabelGenServiceFactory _labelFactory;
     public VehicleFactory(LabelGenServiceFactory labelFactory)
     {
         _labelFactory = labelFactory;
     }

     public Vehicle CreateVehicle(VehicleType vehicleType)
     {
         var label = _labelFactory.GetVinLabelGenService().Generate();

         return vehicleType switch
         {
             VehicleType.Car => new Car(label),
             VehicleType.Bike => new Bike(label),
             VehicleType.Truck => new Truck(label),
             _ => throw new ArgumentException("Invalid vehicle type")
         };
     }
 }
```

## 4. Conditional Service Resolution 
When dealing with multiple implementations of a service, the Factory Pattern can help resolve the appropriate service based on specific conditions:

> Scenario: if we have solid implementation of multiple services using common interface. we can use factory pattern to resolve the required service inside a factory class.

```
   public class LiveMaintanceService : IMaintanceService
   {
       public MaintanceMode Mode => MaintanceMode.Live;
       public string Perform(string message) => $"Live: {message}";
   }

   public class TestMaintanceService : IMaintanceService
   {
       public MaintanceMode Mode => MaintanceMode.Test;
       public string Perform(string message) => $"Test: {message}";
   }

   public class OfflineMaintanceService : IMaintanceService
   {
       public MaintanceMode Mode => MaintanceMode.Offline;
       public string Perform(string message) => $"Offline: {message}";
   }
```
Let us assume we have some solid implementation of maintance service of different vehicles.

```
 services.AddTransient<IMaintanceService, LiveMaintanceService>();
 services.AddTransient<IMaintanceService, TestMaintanceService>();
 services.AddTransient<IMaintanceService, OfflineMaintanceService>();
```  
Then we create a maintance factory which resolves the specfic service based on the mode.

```
public class MaintanceServiceFactory
{
    private readonly IEnumerable<IMaintanceService> _maintanceServices;
    public MaintanceServiceFactory(IEnumerable<IMaintanceService> maintanceServices)
    {
        _maintanceServices = maintanceServices;
    }
    public IMaintanceService GetMaintanceService(MaintanceMode mMode)
    {
        return _maintanceServices.FirstOrDefault(e => e.Mode == mMode)
            ?? throw new NotSupportedException();
    }
}
```
Finally we need to add the factory class also to DI
` services.AddSingleton<MaintanceServiceFactory>();`


## 5. Encapsulate Service Initialization
Some services require initial checks before performing operations. The Factory Pattern can encapsulate this initialization logic:

> Scenario: Imagine in a real world scenario we need to do some checks before oil change. 

```
    public class OilService
    {
        private bool _isVehicleSwitchedOff = false;
        public void InitialCheck()
        {
            //perform initial check before oil change
            _isVehicleSwitchedOff = true;
        }
        public string DrainOil(string performedBy)
        {
            if (!_isVehicleSwitchedOff)
                throw new InvalidOperationException("Vehicle is not ready");
            return $"Draining oil performed by: {performedBy}";
        }

        public string AddOil(string performedBy)
        {
            if (!_isVehicleSwitchedOff)
                throw new InvalidOperationException("Vehicle is not ready");
            return $"Adding new oil performed by: {performedBy}";
        }
    }

 public class OilServiceFactory
 {
     public OilService CreateOilService()
     {
         var service = new OilService();
         service.InitialCheck();
         return service;
     }
 }
```

## 6. Abstract Factory With Dependency Injection
An abstract factory can act as an abstraction over other factories, providing a higher level of encapsulation:

> Scenario: Imagine we need to have sperate sets of vehicles called smart vehicles.

```
 public class SmartVehicleFactory : IVehicleFactory
 {
     private readonly LabelGenServiceFactory _labelFactory;
     public SmartVehicleFactory(LabelGenServiceFactory labelFactory)
     {
         _labelFactory = labelFactory;
     }

     public Vehicle CreateVehicle(VehicleType vehicleType)
     {
         var label = _labelFactory.GetVinLabelGenService().Generate();

         return vehicleType switch
         {
             VehicleType.Car => new SmartCar(label),
             VehicleType.Bike => new SmartBike(label),
             VehicleType.Truck => new SmartTruck(label),
             _ => throw new ArgumentException("Invalid vehicle type")
         };
     }
 }  

 public class VehicleFactoryManager
 {
     private readonly IEnumerable<IVehicleFactory> _vehicleFactories;
     public VehicleFactoryManager(IEnumerable<IVehicleFactory> deviceFactories)
     {
         _vehicleFactories = deviceFactories;
     }
     public IVehicleFactory GetClassicFactory()
     {
         return _vehicleFactories.OfType<VehicleFactory>()
             .FirstOrDefault()!;
     }
     public IVehicleFactory GetSmartFactory()
     {
         return _vehicleFactories.OfType<SmartVehicleFactory>()
             .FirstOrDefault()!;
     }
 }
```
By leveraging the Factory Design Pattern with Dependency Injection, we can achieve a more flexible and decoupled architecture, making our code easier to maintain and extend.


## When we have to use to use abstract class or an interface in the Factory Design Pattern?

The choice between using an abstract class or an interface in the Factory Design Pattern depends on your specific needs and design preferences.Here’s a breakdown of when to use each, along with
examples:

**When to Use an Interface**

Use an interface when you want to define a contract for creating objects without specifying any implementation details. Interfaces are ideal when you have multiple unrelated classes that need to be created by the factory.

**Example Use Case: Payment Processing System**

Imagine you have a payment processing system that supports multiple payment methods like Credit Card, PayPal, and Bank Transfer.

```
public interface IPayment
{
  void ProcessPayment(decimal amount);
}

public class CreditCardPayment : IPayment
{
  public void ProcessPayment(decimal amount)
  {
    Console.WriteLine($"Processing credit card payment of {amount}");
  }
}
public class PayPalPayment : IPayment
{
  public void ProcessPayment(decimal amount)
  {
    Console.WriteLine($"Processing PayPal payment of {amount}");
  }
}
public class BankTransferPayment : IPayment
{
  public void ProcessPayment(decimal amount)
  {
    Console.WriteLine($"Processing bank transfer payment of {amount}");
  }
}

```
Create the factory class
```
public class PaymentFactory
{
  public IPayment CreatePayment(string paymentType)
  {
    if (paymentType.Equals("CreditCard")) {
      return new CreditCardPayment();
    } else if (paymentType.Equals("PayPal")) {
      return new PayPalPayment();
    } else if (paymentType.Equals("BankTransfer")) {
      return new BankTransferPayment();
    } else {
      throw new ArgumentException("Invalid payment type");
    }
  }
}
```

**When to Use an Abstract Class**

Use an abstract class when you want to provide a partial implementation for the factory method. Abstract classes are useful when you have a common implementation for some methods in the factory, but you want subclasses to implement the factory method.

**Example Use Case: Document Generation System**

Imagine you have a document generation system that supports different types of documents like PDF, Word, and Excel.

```
public abstract class Document
{
  public abstract void Generate();

  public void Save() { Console.WriteLine("Saving document..."); }
}

public class PdfDocument : Document
{
  public override void Generate()
  {
    Console.WriteLine("Generating PDF document");
  }
}
public class WordDocument : Document
{
  public override void Generate()
  {
    Console.WriteLine("Generating Word document");
  }
}
public class ExcelDocument : Document
{
  public override void Generate()
  {
    Console.WriteLine("Generating Excel document");
  }
}

```

Create the factory class

```
public class DocumentFactory
{
  public Document CreateDocument(string documentType)
  {
    if (documentType.Equals("PDF")) {
      return new PdfDocument();
    } else if (documentType.Equals("Word")) {
      return new WordDocument();
    } else if (documentType.Equals("Excel")) {
      return new ExcelDocument();
    } else {
      throw new ArgumentException("Invalid document type");
    }
  }
}

```

**Summary**
Use an interface when you need a simple factory pattern with just one method to create objects and
when you have multiple unrelated classes.
Use an abstract class when you need a more complex factory pattern with additional methods or
common implementation details.
